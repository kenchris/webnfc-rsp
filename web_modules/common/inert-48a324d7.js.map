{"version":3,"file":"inert-48a324d7.js","sources":["../../node_modules/blocking-elements/dist/blocking-elements.js","../../node_modules/wicg-inert/src/inert.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(() => {\n    var _a, _b, _c;\n    /* Symbols for private properties */\n    const _blockingElements = Symbol();\n    const _alreadyInertElements = Symbol();\n    const _topElParents = Symbol();\n    const _siblingsToRestore = Symbol();\n    const _parentMO = Symbol();\n    /* Symbols for private static methods */\n    const _topChanged = Symbol();\n    const _swapInertedSibling = Symbol();\n    const _inertSiblings = Symbol();\n    const _restoreInertedSiblings = Symbol();\n    const _getParents = Symbol();\n    const _getDistributedChildren = Symbol();\n    const _isInertable = Symbol();\n    const _handleMutations = Symbol();\n    class BlockingElementsImpl {\n        constructor() {\n            /**\n             * The blocking elements.\n             */\n            this[_a] = [];\n            /**\n             * Used to keep track of the parents of the top element, from the element\n             * itself up to body. When top changes, the old top might have been removed\n             * from the document, so we need to memoize the inerted parents' siblings\n             * in order to restore their inerteness when top changes.\n             */\n            this[_b] = [];\n            /**\n             * Elements that are already inert before the first blocking element is\n             * pushed.\n             */\n            this[_c] = new Set();\n        }\n        destructor() {\n            // Restore original inertness.\n            this[_restoreInertedSiblings](this[_topElParents]);\n            // Note we don't want to make these properties nullable on the class,\n            // since then we'd need non-null casts in many places. Calling a method on\n            // a BlockingElements instance after calling destructor will result in an\n            // exception.\n            const nullable = this;\n            nullable[_blockingElements] = null;\n            nullable[_topElParents] = null;\n            nullable[_alreadyInertElements] = null;\n        }\n        get top() {\n            const elems = this[_blockingElements];\n            return elems[elems.length - 1] || null;\n        }\n        push(element) {\n            if (!element || element === this.top) {\n                return;\n            }\n            // Remove it from the stack, we'll bring it to the top.\n            this.remove(element);\n            this[_topChanged](element);\n            this[_blockingElements].push(element);\n        }\n        remove(element) {\n            const i = this[_blockingElements].indexOf(element);\n            if (i === -1) {\n                return false;\n            }\n            this[_blockingElements].splice(i, 1);\n            // Top changed only if the removed element was the top element.\n            if (i === this[_blockingElements].length) {\n                this[_topChanged](this.top);\n            }\n            return true;\n        }\n        pop() {\n            const top = this.top;\n            top && this.remove(top);\n            return top;\n        }\n        has(element) {\n            return this[_blockingElements].indexOf(element) !== -1;\n        }\n        /**\n         * Sets `inert` to all document elements except the new top element, its\n         * parents, and its distributed content.\n         */\n        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {\n            const toKeepInert = this[_alreadyInertElements];\n            const oldParents = this[_topElParents];\n            // No new top, reset old top if any.\n            if (!newTop) {\n                this[_restoreInertedSiblings](oldParents);\n                toKeepInert.clear();\n                this[_topElParents] = [];\n                return;\n            }\n            const newParents = this[_getParents](newTop);\n            // New top is not contained in the main document!\n            if (newParents[newParents.length - 1].parentNode !== document.body) {\n                throw Error('Non-connected element cannot be a blocking element');\n            }\n            // Cast here because we know we'll call _inertSiblings on newParents\n            // below.\n            this[_topElParents] = newParents;\n            const toSkip = this[_getDistributedChildren](newTop);\n            // No previous top element.\n            if (!oldParents.length) {\n                this[_inertSiblings](newParents, toSkip, toKeepInert);\n                return;\n            }\n            let i = oldParents.length - 1;\n            let j = newParents.length - 1;\n            // Find common parent. Index 0 is the element itself (so stop before it).\n            while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {\n                i--;\n                j--;\n            }\n            // If up the parents tree there are 2 elements that are siblings, swap\n            // the inerted sibling.\n            if (oldParents[i] !== newParents[j]) {\n                this[_swapInertedSibling](oldParents[i], newParents[j]);\n            }\n            // Restore old parents siblings inertness.\n            i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));\n            // Make new parents siblings inert.\n            j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);\n        }\n        /**\n         * Swaps inertness between two sibling elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_swapInertedSibling](oldInert, newInert) {\n            const siblingsToRestore = oldInert[_siblingsToRestore];\n            // oldInert is not contained in siblings to restore, so we have to check\n            // if it's inertable and if already inert.\n            if (this[_isInertable](oldInert) && !oldInert.inert) {\n                oldInert.inert = true;\n                siblingsToRestore.add(oldInert);\n            }\n            // If newInert was already between the siblings to restore, it means it is\n            // inertable and must be restored.\n            if (siblingsToRestore.has(newInert)) {\n                newInert.inert = false;\n                siblingsToRestore.delete(newInert);\n            }\n            newInert[_parentMO] = oldInert[_parentMO];\n            newInert[_siblingsToRestore] = siblingsToRestore;\n            oldInert[_parentMO] = undefined;\n            oldInert[_siblingsToRestore] = undefined;\n        }\n        /**\n         * Restores original inertness to the siblings of the elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_restoreInertedSiblings](elements) {\n            for (const element of elements) {\n                const mo = element[_parentMO];\n                mo.disconnect();\n                element[_parentMO] = undefined;\n                const siblings = element[_siblingsToRestore];\n                for (const sibling of siblings) {\n                    sibling.inert = false;\n                }\n                element[_siblingsToRestore] = undefined;\n            }\n        }\n        /**\n         * Inerts the siblings of the elements except the elements to skip. Stores\n         * the inerted siblings into the element's symbol `_siblingsToRestore`.\n         * Pass `toKeepInert` to collect the already inert elements.\n         * Sets the property `inert` over the attribute since the inert spec\n         * doesn't specify if it should be reflected.\n         * https://html.spec.whatwg.org/multipage/interaction.html#inert\n         */\n        [_inertSiblings](elements, toSkip, toKeepInert) {\n            for (const element of elements) {\n                // Assume element is not a Document, so it must have a parentNode.\n                const parent = element.parentNode;\n                const children = parent.children;\n                const inertedSiblings = new Set();\n                for (let j = 0; j < children.length; j++) {\n                    const sibling = children[j];\n                    // Skip the input element, if not inertable or to be skipped.\n                    if (sibling === element || !this[_isInertable](sibling) ||\n                        (toSkip && toSkip.has(sibling))) {\n                        continue;\n                    }\n                    // Should be collected since already inerted.\n                    if (toKeepInert && sibling.inert) {\n                        toKeepInert.add(sibling);\n                    }\n                    else {\n                        sibling.inert = true;\n                        inertedSiblings.add(sibling);\n                    }\n                }\n                // Store the siblings that were inerted.\n                element[_siblingsToRestore] = inertedSiblings;\n                // Observe only immediate children mutations on the parent.\n                const mo = new MutationObserver(this[_handleMutations].bind(this));\n                element[_parentMO] = mo;\n                let parentToObserve = parent;\n                // If we're using the ShadyDOM polyfill, then our parent could be a\n                // shady root, which is an object that acts like a ShadowRoot, but isn't\n                // actually a node in the real DOM. Observe the real DOM parent instead.\n                const maybeShadyRoot = parentToObserve;\n                if (maybeShadyRoot.__shady && maybeShadyRoot.host) {\n                    parentToObserve = maybeShadyRoot.host;\n                }\n                mo.observe(parentToObserve, {\n                    childList: true,\n                });\n            }\n        }\n        /**\n         * Handles newly added/removed nodes by toggling their inertness.\n         * It also checks if the current top Blocking Element has been removed,\n         * notifying and removing it.\n         */\n        [_handleMutations](mutations) {\n            const parents = this[_topElParents];\n            const toKeepInert = this[_alreadyInertElements];\n            for (const mutation of mutations) {\n                // If the target is a shadowRoot, get its host as we skip shadowRoots when\n                // computing _topElParents.\n                const target = mutation.target.host || mutation.target;\n                const idx = target === document.body ?\n                    parents.length :\n                    parents.indexOf(target);\n                const inertedChild = parents[idx - 1];\n                const inertedSiblings = inertedChild[_siblingsToRestore];\n                // To restore.\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const sibling = mutation.removedNodes[i];\n                    if (sibling === inertedChild) {\n                        console.info('Detected removal of the top Blocking Element.');\n                        this.pop();\n                        return;\n                    }\n                    if (inertedSiblings.has(sibling)) {\n                        sibling.inert = false;\n                        inertedSiblings.delete(sibling);\n                    }\n                }\n                // To inert.\n                for (let i = 0; i < mutation.addedNodes.length; i++) {\n                    const sibling = mutation.addedNodes[i];\n                    if (!this[_isInertable](sibling)) {\n                        continue;\n                    }\n                    if (toKeepInert && sibling.inert) {\n                        toKeepInert.add(sibling);\n                    }\n                    else {\n                        sibling.inert = true;\n                        inertedSiblings.add(sibling);\n                    }\n                }\n            }\n        }\n        /**\n         * Returns if the element is inertable.\n         */\n        [_isInertable](element) {\n            return false === /^(style|template|script)$/.test(element.localName);\n        }\n        /**\n         * Returns the list of newParents of an element, starting from element\n         * (included) up to `document.body` (excluded).\n         */\n        [_getParents](element) {\n            const parents = [];\n            let current = element;\n            // Stop to body.\n            while (current && current !== document.body) {\n                // Skip shadow roots.\n                if (current.nodeType === Node.ELEMENT_NODE) {\n                    parents.push(current);\n                }\n                // ShadowDom v1\n                if (current.assignedSlot) {\n                    // Collect slots from deepest slot to top.\n                    while (current = current.assignedSlot) {\n                        parents.push(current);\n                    }\n                    // Continue the search on the top slot.\n                    current = parents.pop();\n                    continue;\n                }\n                current = current.parentNode ||\n                    current.host;\n            }\n            return parents;\n        }\n        /**\n         * Returns the distributed children of the element's shadow root.\n         * Returns null if the element doesn't have a shadow root.\n         */\n        [_getDistributedChildren](element) {\n            const shadowRoot = element.shadowRoot;\n            if (!shadowRoot) {\n                return null;\n            }\n            const result = new Set();\n            let i;\n            let j;\n            let nodes;\n            const slots = shadowRoot.querySelectorAll('slot');\n            if (slots.length && slots[0].assignedNodes) {\n                for (i = 0; i < slots.length; i++) {\n                    nodes = slots[i].assignedNodes({\n                        flatten: true,\n                    });\n                    for (j = 0; j < nodes.length; j++) {\n                        if (nodes[j].nodeType === Node.ELEMENT_NODE) {\n                            result.add(nodes[j]);\n                        }\n                    }\n                }\n                // No need to search for <content>.\n            }\n            return result;\n        }\n    }\n    document.$blockingElements =\n        new BlockingElementsImpl();\n})();\n//# sourceMappingURL=blocking-elements.js.map","/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n// Convenience function for converting NodeLists.\n/** @type {typeof Array.prototype.slice} */\nconst slice = Array.prototype.slice;\n\n/**\n * IE has a non-standard name for \"matches\".\n * @type {typeof Element.prototype.matches}\n */\nconst matches =\n    Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n/** @type {string} */\nconst _focusableElementsString = ['a[href]',\n                                  'area[href]',\n                                  'input:not([disabled])',\n                                  'select:not([disabled])',\n                                  'textarea:not([disabled])',\n                                  'button:not([disabled])',\n                                  'iframe',\n                                  'object',\n                                  'embed',\n                                  '[contenteditable]'].join(',');\n\n/**\n * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n * attribute.\n *\n * Its main functions are:\n *\n * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n *   instance exists for each focusable node which has at least one inert root as an ancestor.\n *\n * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n *   attribute is removed from the root node). This is handled in the destructor, which calls the\n *   `deregister` method on `InertManager` for each managed inert node.\n */\nclass InertRoot {\n  /**\n   * @param {!Element} rootElement The Element at the root of the inert subtree.\n   * @param {!InertManager} inertManager The global singleton InertManager object.\n   */\n  constructor(rootElement, inertManager) {\n    /** @type {!InertManager} */\n    this._inertManager = inertManager;\n\n    /** @type {!Element} */\n    this._rootElement = rootElement;\n\n    /**\n     * @type {!Set<!InertNode>}\n     * All managed focusable nodes in this InertRoot's subtree.\n     */\n    this._managedNodes = new Set();\n\n    // Make the subtree hidden from assistive technology\n    if (this._rootElement.hasAttribute('aria-hidden')) {\n      /** @type {?string} */\n      this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n    } else {\n      this._savedAriaHidden = null;\n    }\n    this._rootElement.setAttribute('aria-hidden', 'true');\n\n    // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n    this._makeSubtreeUnfocusable(this._rootElement);\n\n    // Watch for:\n    // - any additions in the subtree: make them unfocusable too\n    // - any removals from the subtree: remove them from this inert root's managed nodes\n    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n    //   element, make that node a managed node.\n    this._observer = new MutationObserver(this._onMutation.bind(this));\n    this._observer.observe(this._rootElement, {attributes: true, childList: true, subtree: true});\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n   * stored in this object and updates the state of all of the managed nodes.\n   */\n  destructor() {\n    this._observer.disconnect();\n\n    if (this._rootElement) {\n      if (this._savedAriaHidden !== null) {\n        this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n      } else {\n        this._rootElement.removeAttribute('aria-hidden');\n      }\n    }\n\n    this._managedNodes.forEach(function(inertNode) {\n      this._unmanageNode(inertNode.node);\n    }, this);\n\n    // Note we cast the nulls to the ANY type here because:\n    // 1) We want the class properties to be declared as non-null, or else we\n    //    need even more casts throughout this code. All bets are off if an\n    //    instance has been destroyed and a method is called.\n    // 2) We don't want to cast \"this\", because we want type-aware optimizations\n    //    to know which properties we're setting.\n    this._observer = /** @type {?} */ (null);\n    this._rootElement = /** @type {?} */ (null);\n    this._managedNodes = /** @type {?} */ (null);\n    this._inertManager = /** @type {?} */ (null);\n  }\n\n  /**\n   * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n   */\n  get managedNodes() {\n    return new Set(this._managedNodes);\n  }\n\n  /** @return {boolean} */\n  get hasSavedAriaHidden() {\n    return this._savedAriaHidden !== null;\n  }\n\n  /** @param {?string} ariaHidden */\n  set savedAriaHidden(ariaHidden) {\n    this._savedAriaHidden = ariaHidden;\n  }\n\n  /** @return {?string} */\n  get savedAriaHidden() {\n    return this._savedAriaHidden;\n  }\n\n  /**\n   * @param {!Node} startNode\n   */\n  _makeSubtreeUnfocusable(startNode) {\n    composedTreeWalk(startNode, (node) => this._visitNode(node));\n\n    let activeElement = document.activeElement;\n\n    if (!document.body.contains(startNode)) {\n      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n      let node = startNode;\n      /** @type {!ShadowRoot|undefined} */\n      let root = undefined;\n      while (node) {\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          root = /** @type {!ShadowRoot} */ (node);\n          break;\n        }\n        node = node.parentNode;\n      }\n      if (root) {\n        activeElement = root.activeElement;\n      }\n    }\n    if (startNode.contains(activeElement)) {\n      activeElement.blur();\n      // In IE11, if an element is already focused, and then set to tabindex=-1\n      // calling blur() will not actually move the focus.\n      // To work around this we call focus() on the body instead.\n      if (activeElement === document.activeElement) {\n        document.body.focus();\n      }\n    }\n  }\n\n  /**\n   * @param {!Node} node\n   */\n  _visitNode(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    const element = /** @type {!Element} */ (node);\n\n    // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n    // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n    if (element !== this._rootElement && element.hasAttribute('inert')) {\n      this._adoptInertRoot(element);\n    }\n\n    if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n      this._manageNode(element);\n    }\n  }\n\n  /**\n   * Register the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n  _manageNode(node) {\n    const inertNode = this._inertManager.register(node, this);\n    this._managedNodes.add(inertNode);\n  }\n\n  /**\n   * Unregister the given node with this InertRoot and with InertManager.\n   * @param {!Node} node\n   */\n  _unmanageNode(node) {\n    const inertNode = this._inertManager.deregister(node, this);\n    if (inertNode) {\n      this._managedNodes.delete(inertNode);\n    }\n  }\n\n  /**\n   * Unregister the entire subtree starting at `startNode`.\n   * @param {!Node} startNode\n   */\n  _unmanageSubtree(startNode) {\n    composedTreeWalk(startNode, (node) => this._unmanageNode(node));\n  }\n\n  /**\n   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n   * @param {!Element} node\n   */\n  _adoptInertRoot(node) {\n    let inertSubroot = this._inertManager.getInertRoot(node);\n\n    // During initialisation this inert root may not have been registered yet,\n    // so register it now if need be.\n    if (!inertSubroot) {\n      this._inertManager.setInert(node, true);\n      inertSubroot = this._inertManager.getInertRoot(node);\n    }\n\n    inertSubroot.managedNodes.forEach(function(savedInertNode) {\n      this._manageNode(savedInertNode.node);\n    }, this);\n  }\n\n  /**\n   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n  _onMutation(records, self) {\n    records.forEach(function(record) {\n      const target = /** @type {!Element} */ (record.target);\n      if (record.type === 'childList') {\n        // Manage added nodes\n        slice.call(record.addedNodes).forEach(function(node) {\n          this._makeSubtreeUnfocusable(node);\n        }, this);\n\n        // Un-manage removed nodes\n        slice.call(record.removedNodes).forEach(function(node) {\n          this._unmanageSubtree(node);\n        }, this);\n      } else if (record.type === 'attributes') {\n        if (record.attributeName === 'tabindex') {\n          // Re-initialise inert node if tabindex changes\n          this._manageNode(target);\n        } else if (target !== this._rootElement &&\n                   record.attributeName === 'inert' &&\n                   target.hasAttribute('inert')) {\n          // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n          // already managed nodes from this inert subroot.\n          this._adoptInertRoot(target);\n          const inertSubroot = this._inertManager.getInertRoot(target);\n          this._managedNodes.forEach(function(managedNode) {\n            if (target.contains(managedNode.node)) {\n              inertSubroot._manageNode(managedNode.node);\n            }\n          });\n        }\n      }\n    }, this);\n  }\n}\n\n/**\n * `InertNode` initialises and manages a single inert node.\n * A node is inert if it is a descendant of one or more inert root elements.\n *\n * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n * is intrinsically focusable or not.\n *\n * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n * or removes the `tabindex` attribute if the element is intrinsically focusable.\n */\nclass InertNode {\n  /**\n   * @param {!Node} node A focusable element to be made inert.\n   * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n   */\n  constructor(node, inertRoot) {\n    /** @type {!Node} */\n    this._node = node;\n\n    /** @type {boolean} */\n    this._overrodeFocusMethod = false;\n\n    /**\n     * @type {!Set<!InertRoot>} The set of descendant inert roots.\n     *    If and only if this set becomes empty, this node is no longer inert.\n     */\n    this._inertRoots = new Set([inertRoot]);\n\n    /** @type {?number} */\n    this._savedTabIndex = null;\n\n    /** @type {boolean} */\n    this._destroyed = false;\n\n    // Save any prior tabindex info and make this node untabbable\n    this.ensureUntabbable();\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.\n   * This makes the managed node focusable again and deletes all of the previously stored state.\n   */\n  destructor() {\n    this._throwIfDestroyed();\n\n    if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n      const element = /** @type {!Element} */ (this._node);\n      if (this._savedTabIndex !== null) {\n        element.setAttribute('tabindex', this._savedTabIndex);\n      } else {\n        element.removeAttribute('tabindex');\n      }\n\n      // Use `delete` to restore native focus method.\n      if (this._overrodeFocusMethod) {\n        delete element.focus;\n      }\n    }\n\n    // See note in InertRoot.destructor for why we cast these nulls to ANY.\n    this._node = /** @type {?} */ (null);\n    this._inertRoots = /** @type {?} */ (null);\n    this._destroyed = true;\n  }\n\n  /**\n   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n   * If the object has been destroyed, any attempt to access it will cause an exception.\n   */\n  get destroyed() {\n    return /** @type {!InertNode} */ (this)._destroyed;\n  }\n\n  /**\n   * Throw if user tries to access destroyed InertNode.\n   */\n  _throwIfDestroyed() {\n    if (this.destroyed) {\n      throw new Error('Trying to access destroyed InertNode');\n    }\n  }\n\n  /** @return {boolean} */\n  get hasSavedTabIndex() {\n    return this._savedTabIndex !== null;\n  }\n\n  /** @return {!Node} */\n  get node() {\n    this._throwIfDestroyed();\n    return this._node;\n  }\n\n  /** @param {?number} tabIndex */\n  set savedTabIndex(tabIndex) {\n    this._throwIfDestroyed();\n    this._savedTabIndex = tabIndex;\n  }\n\n  /** @return {?number} */\n  get savedTabIndex() {\n    this._throwIfDestroyed();\n    return this._savedTabIndex;\n  }\n\n  /** Save the existing tabindex value and make the node untabbable and unfocusable */\n  ensureUntabbable() {\n    if (this.node.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    const element = /** @type {!Element} */ (this.node);\n    if (matches.call(element, _focusableElementsString)) {\n      if (/** @type {!HTMLElement} */ (element).tabIndex === -1 &&\n          this.hasSavedTabIndex) {\n        return;\n      }\n\n      if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n      }\n      element.setAttribute('tabindex', '-1');\n      if (element.nodeType === Node.ELEMENT_NODE) {\n        element.focus = function() {};\n        this._overrodeFocusMethod = true;\n      }\n    } else if (element.hasAttribute('tabindex')) {\n      this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n      element.removeAttribute('tabindex');\n    }\n  }\n\n  /**\n   * Add another inert root to this inert node's set of managing inert roots.\n   * @param {!InertRoot} inertRoot\n   */\n  addInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.add(inertRoot);\n  }\n\n  /**\n   * Remove the given inert root from this inert node's set of managing inert roots.\n   * If the set of managing inert roots becomes empty, this node is no longer inert,\n   * so the object should be destroyed.\n   * @param {!InertRoot} inertRoot\n   */\n  removeInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.delete(inertRoot);\n    if (this._inertRoots.size === 0) {\n      this.destructor();\n    }\n  }\n}\n\n/**\n * InertManager is a per-document singleton object which manages all inert roots and nodes.\n *\n * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n * is created for each such node, via the `_managedNodes` map.\n */\nclass InertManager {\n  /**\n   * @param {!Document} document\n   */\n  constructor(document) {\n    if (!document) {\n      throw new Error('Missing required argument; InertManager needs to wrap a document.');\n    }\n\n    /** @type {!Document} */\n    this._document = document;\n\n    /**\n     * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertNode>}\n     */\n    this._managedNodes = new Map();\n\n    /**\n     * All inert roots known to this InertManager. In a map to allow looking up by Node.\n     * @type {!Map<!Node, !InertRoot>}\n     */\n    this._inertRoots = new Map();\n\n    /**\n     * Observer for mutations on `document.body`.\n     * @type {!MutationObserver}\n     */\n    this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n    // Add inert style.\n    addInertStyle(document.head || document.body || document.documentElement);\n\n    // Wait for document to be loaded.\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n    } else {\n      this._onDocumentLoaded();\n    }\n  }\n\n  /**\n   * Set whether the given element should be an inert root or not.\n   * @param {!Element} root\n   * @param {boolean} inert\n   */\n  setInert(root, inert) {\n    if (inert) {\n      if (this._inertRoots.has(root)) { // element is already inert\n        return;\n      }\n\n      const inertRoot = new InertRoot(root, this);\n      root.setAttribute('inert', '');\n      this._inertRoots.set(root, inertRoot);\n      // If not contained in the document, it must be in a shadowRoot.\n      // Ensure inert styles are added there.\n      if (!this._document.body.contains(root)) {\n        let parent = root.parentNode;\n        while (parent) {\n          if (parent.nodeType === 11) {\n            addInertStyle(parent);\n          }\n          parent = parent.parentNode;\n        }\n      }\n    } else {\n      if (!this._inertRoots.has(root)) { // element is already non-inert\n        return;\n      }\n\n      const inertRoot = this._inertRoots.get(root);\n      inertRoot.destructor();\n      this._inertRoots.delete(root);\n      root.removeAttribute('inert');\n    }\n  }\n\n  /**\n   * Get the InertRoot object corresponding to the given inert root element, if any.\n   * @param {!Node} element\n   * @return {!InertRoot|undefined}\n   */\n  getInertRoot(element) {\n    return this._inertRoots.get(element);\n  }\n\n  /**\n   * Register the given InertRoot as managing the given node.\n   * In the case where the node has a previously existing inert root, this inert root will\n   * be added to its set of inert roots.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {!InertNode} inertNode\n   */\n  register(node, inertRoot) {\n    let inertNode = this._managedNodes.get(node);\n    if (inertNode !== undefined) { // node was already in an inert subtree\n      inertNode.addInertRoot(inertRoot);\n    } else {\n      inertNode = new InertNode(node, inertRoot);\n    }\n\n    this._managedNodes.set(node, inertNode);\n\n    return inertNode;\n  }\n\n  /**\n   * De-register the given InertRoot as managing the given inert node.\n   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n   * node from the InertManager's set of managed nodes if it is destroyed.\n   * If the node is not currently managed, this is essentially a no-op.\n   * @param {!Node} node\n   * @param {!InertRoot} inertRoot\n   * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n   */\n  deregister(node, inertRoot) {\n    const inertNode = this._managedNodes.get(node);\n    if (!inertNode) {\n      return null;\n    }\n\n    inertNode.removeInertRoot(inertRoot);\n    if (inertNode.destroyed) {\n      this._managedNodes.delete(node);\n    }\n\n    return inertNode;\n  }\n\n  /**\n   * Callback used when document has finished loading.\n   */\n  _onDocumentLoaded() {\n    // Find all inert roots in document and make them actually inert.\n    const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n    inertElements.forEach(function(inertElement) {\n      this.setInert(inertElement, true);\n    }, this);\n\n    // Comment this out to use programmatic API only.\n    this._observer.observe(this._document.body, {attributes: true, subtree: true, childList: true});\n  }\n\n  /**\n   * Callback used when mutation observer detects attribute changes.\n   * @param {!Array<!MutationRecord>} records\n   * @param {!MutationObserver} self\n   */\n  _watchForInert(records, self) {\n    const _this = this;\n    records.forEach(function(record) {\n      switch (record.type) {\n      case 'childList':\n        slice.call(record.addedNodes).forEach(function(node) {\n          if (node.nodeType !== Node.ELEMENT_NODE) {\n            return;\n          }\n          const inertElements = slice.call(node.querySelectorAll('[inert]'));\n          if (matches.call(node, '[inert]')) {\n            inertElements.unshift(node);\n          }\n          inertElements.forEach(function(inertElement) {\n            this.setInert(inertElement, true);\n          }, _this);\n        }, _this);\n        break;\n      case 'attributes':\n        if (record.attributeName !== 'inert') {\n          return;\n        }\n        const target = /** @type {!Element} */ (record.target);\n        const inert = target.hasAttribute('inert');\n        _this.setInert(target, inert);\n        break;\n      }\n    }, this);\n  }\n}\n\n/**\n * Recursively walk the composed tree from |node|.\n * @param {!Node} node\n * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n *     before descending into child nodes.\n * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n */\nfunction composedTreeWalk(node, callback, shadowRootAncestor) {\n  if (node.nodeType == Node.ELEMENT_NODE) {\n    const element = /** @type {!Element} */ (node);\n    if (callback) {\n      callback(element);\n    }\n\n    // Descend into node:\n    // If it has a ShadowRoot, ignore all child elements - these will be picked\n    // up by the <content> or <shadow> elements. Descend straight into the\n    // ShadowRoot.\n    const shadowRoot = /** @type {!HTMLElement} */ (element).shadowRoot;\n    if (shadowRoot) {\n      composedTreeWalk(shadowRoot, callback, shadowRoot);\n      return;\n    }\n\n    // If it is a <content> element, descend into distributed elements - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'content') {\n      const content = /** @type {!HTMLContentElement} */ (element);\n      // Verifies if ShadowDom v0 is supported.\n      const distributedNodes = content.getDistributedNodes ?\n        content.getDistributedNodes() : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n\n    // If it is a <slot> element, descend into assigned nodes - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'slot') {\n      const slot = /** @type {!HTMLSlotElement} */ (element);\n      // Verify if ShadowDom v1 is supported.\n      const distributedNodes = slot.assignedNodes ?\n        slot.assignedNodes({flatten: true}) : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n  }\n\n  // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n  // element, nor a <shadow> element recurse normally.\n  let child = node.firstChild;\n  while (child != null) {\n    composedTreeWalk(child, callback, shadowRootAncestor);\n    child = child.nextSibling;\n  }\n}\n\n/**\n * Adds a style element to the node containing the inert specific styles\n * @param {!Node} node\n */\nfunction addInertStyle(node) {\n  if (node.querySelector('style#inert-style')) {\n    return;\n  }\n  const style = document.createElement('style');\n  style.setAttribute('id', 'inert-style');\n  style.textContent = '\\n'+\n                      '[inert] {\\n' +\n                      '  pointer-events: none;\\n' +\n                      '  cursor: default;\\n' +\n                      '}\\n' +\n                      '\\n' +\n                      '[inert], [inert] * {\\n' +\n                      '  user-select: none;\\n' +\n                      '  -webkit-user-select: none;\\n' +\n                      '  -moz-user-select: none;\\n' +\n                      '  -ms-user-select: none;\\n' +\n                      '}\\n';\n  node.appendChild(style);\n}\n\n/** @type {!InertManager} */\nconst inertManager = new InertManager(document);\n\nif (!Element.prototype.hasOwnProperty('inert')) {\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    /** @this {!Element} */\n    get: function() {\n      return this.hasAttribute('inert');\n    },\n    /** @this {!Element} */\n    set: function(inert) {\n      inertManager.setInert(this, inert);\n    },\n  });\n}\n"],"names":["_blockingElements","Symbol","_alreadyInertElements","_topElParents","_siblingsToRestore","_parentMO","_topChanged","_swapInertedSibling","_inertSiblings","_restoreInertedSiblings","_getParents","_getDistributedChildren","_isInertable","_handleMutations","document","$blockingElements","[object Object]","_a","_b","_c","Set","this","elems","length","element","top","remove","push","i","indexOf","splice","newTop","toKeepInert","oldParents","clear","newParents","parentNode","body","Error","toSkip","j","slice","oldInert","newInert","siblingsToRestore","inert","add","has","delete","undefined","elements","disconnect","siblings","sibling","parent","children","inertedSiblings","mo","MutationObserver","bind","parentToObserve","maybeShadyRoot","__shady","host","observe","childList","mutations","parents","mutation","target","idx","inertedChild","removedNodes","console","info","pop","addedNodes","test","localName","current","nodeType","Node","ELEMENT_NODE","assignedSlot","shadowRoot","result","nodes","slots","querySelectorAll","assignedNodes","flatten","Array","prototype","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","constructor","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","_onMutation","attributes","subtree","destructor","removeAttribute","forEach","inertNode","_unmanageNode","node","ariaHidden","startNode","composedTreeWalk","_visitNode","activeElement","contains","root","DOCUMENT_FRAGMENT_NODE","blur","focus","_adoptInertRoot","call","_manageNode","register","deregister","_unmanageSubtree","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","attributeName","managedNode","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","tabIndex","hasSavedTabIndex","addInertRoot","removeInertRoot","size","callback","shadowRootAncestor","content","distributedNodes","getDistributedNodes","slot","child","firstChild","nextSibling","addInertStyle","querySelector","style","createElement","textContent","appendChild","_document","Map","_watchForInert","head","documentElement","readyState","addEventListener","_onDocumentLoaded","set","get","inertElement","_this","inertElements","unshift","hasOwnProperty","Object","defineProperty","enumerable"],"mappings":";;;;;;;;;;;;;;;;AA4DA,sBAEQA,EAAoBC,SACpBC,EAAwBD,SACxBE,EAAgBF,SAChBG,EAAqBH,SACrBI,EAAYJ,SAGZK,EAAcL,SACdM,EAAsBN,SACtBO,EAAiBP,SACjBQ,EAA0BR,SAC1BS,EAAcT,SACdU,EAA0BV,SAC1BW,EAAeX,SACfY,EAAmBZ,SAuWxBa,SAA0CC,kBACvC,UAlVJC,mBAISC,GAA+C,QAQ/CC,GAAsC,QAMtCC,GAA0B,IAAIC,IAErCJ,kBAEOP,GAAyBY,KAAKlB,IAKlBkB,KAKRrB,GAAqB,KALbqB,KAMRlB,GAAiB,KANTkB,KAORnB,GAAyB,qBAI5BoB,EAAQD,KAAKrB,UACZsB,EAAMA,EAAMC,OAAS,IAAM,KAGpCP,KAAKQ,GACEA,GAAWA,IAAYH,KAAKI,WAI5BC,OAAOF,QACPlB,GAAakB,QACbxB,GAAmB2B,KAAKH,IAG/BR,OAAOQ,SACCI,EAAIP,KAAKrB,GAAmB6B,QAAQL,UAC/B,IAAPI,SAGC5B,GAAmB8B,OAAOF,EAAG,GAE9BA,IAAMP,KAAKrB,GAAmBuB,aAC3BjB,GAAae,KAAKI,MAElB,GAGTT,YACQS,EAAMJ,KAAKI,WACjBA,GAAOJ,KAAKK,OAAOD,GACZA,EAGTT,IAAIQ,UACmD,IAA9CH,KAAKrB,GAAmB6B,QAAQL,KAOlCP,EA3ECjB,EAAiBkB,EAQjBf,EAAagB,EAMbjB,EA6DAI,IAAayB,SACbC,EAAcX,KAAKnB,GACnB+B,EAAaZ,KAAKlB,OAEnB4B,cACEtB,GAAyBwB,GAC9BD,EAAYE,kBACP/B,GAAiB,UAIlBgC,EAAad,KAAKX,GAAaqB,MAEjCI,EAAWA,EAAWZ,OAAS,GAAGa,aAAetB,SAASuB,WACtDC,MAAM,2DAITnC,GAAiBgC,QAEhBI,EAASlB,KAAKV,GAAyBoB,OAGxCE,EAAWV,wBACTf,GAAgB2B,EAAYI,EAAQP,OAIvCJ,EAAIK,EAAWV,OAAS,EACxBiB,EAAIL,EAAWZ,OAAS,OAErBK,EAAI,GAAKY,EAAI,GAAKP,EAAWL,KAAOO,EAAWK,IACpDZ,IACAY,IAIEP,EAAWL,KAAOO,EAAWK,SAC1BjC,GAAqB0B,EAAWL,GAAIO,EAAWK,IAGtDZ,EAAI,GAAKP,KAAKZ,GAAyBwB,EAAWQ,MAAM,EAAGb,IAE3DY,EAAI,GAAKnB,KAAKb,GAAgB2B,EAAWM,MAAM,EAAGD,GAAID,EAAQ,OASxDhC,GACJmC,EAA4BC,SACxBC,EAAoBF,EAAStC,GAG/BiB,KAAKT,GAAc8B,KAAcA,EAASG,QAC5CH,EAASG,OAAQ,EACjBD,EAAkBE,IAAIJ,IAIpBE,EAAkBG,IAAIJ,KACxBA,EAASE,OAAQ,EACjBD,EAAkBI,OAAOL,IAE3BA,EAAStC,GAAaqC,EAASrC,GAC/BsC,EAASvC,GAAsBwC,EAC9BF,EAAmCrC,QAAa4C,EAChDP,EAAmCtC,QAAsB6C,GASpDxC,GAAyByC,OAC1B,MAAM1B,KAAW0B,EAAU,CACnB1B,EAAQnB,GAChB8C,aACF3B,EAAkCnB,QAAa4C,QAC1CG,EAAW5B,EAAQpB,OACpB,MAAMiD,KAAWD,EACpBC,EAAQR,OAAQ,EAEjBrB,EAAkCpB,QAAsB6C,IAYrDzC,GACJ0C,EAAmCX,EACnCP,OACG,MAAMR,KAAW0B,EAAU,OAExBI,EAAS9B,EAAQY,WACjBmB,EAAWD,EAAOC,SAClBC,EAAkB,IAAIpC,QACvB,IAAIoB,EAAI,EAAGA,EAAIe,EAAShC,OAAQiB,IAAK,OAClCa,EAAUE,EAASf,GAErBa,IAAY7B,IAAYH,KAAKT,GAAcyC,IAC1Cd,GAAUA,EAAOQ,IAAIM,KAItBrB,GAAeqB,EAAQR,MACzBb,EAAYc,IAAIO,IAEhBA,EAAQR,OAAQ,EAChBW,EAAgBV,IAAIO,KAIxB7B,EAAQpB,GAAsBoD,QAExBC,EAAK,IAAIC,iBAAiBrC,KAAKR,GAAkB8C,KAAKtC,OAC5DG,EAAQnB,GAAaoD,MACjBG,EAAkBN,QAIhBO,EAAiBD,EACnBC,EAAeC,SAAWD,EAAeE,OAC3CH,EAAkBC,EAAeE,MAEnCN,EAAGO,QAAQJ,EAAiB,CAC1BK,WAAW,MAUTpD,GAAkBqD,SAClBC,EAAU9C,KAAKlB,GACf6B,EAAcX,KAAKnB,OACpB,MAAMkE,KAAYF,EAAW,OAG1BG,EAAUD,EAASC,OAAsBN,MAAQK,EAASC,OAC1DC,EAAMD,IAAWvD,SAASuB,KAC5B8B,EAAQ5C,OACR4C,EAAQtC,QAAQwC,GACdE,EAAeJ,EAAQG,EAAM,GAC7Bd,EAAkBe,EAAanE,OAGhC,IAAIwB,EAAI,EAAGA,EAAIwC,EAASI,aAAajD,OAAQK,IAAK,OAC/CyB,EAAUe,EAASI,aAAa5C,MAClCyB,IAAYkB,SACdE,QAAQC,KAAK,2DACRC,MAGHnB,EAAgBT,IAAIM,KACtBA,EAAQR,OAAQ,EAChBW,EAAgBR,OAAOK,QAKtB,IAAIzB,EAAI,EAAGA,EAAIwC,EAASQ,WAAWrD,OAAQK,IAAK,OAC7CyB,EAAUe,EAASQ,WAAWhD,GAC/BP,KAAKT,GAAcyC,KAGpBrB,GAAeqB,EAAQR,MACzBb,EAAYc,IAAIO,IAEhBA,EAAQR,OAAQ,EAChBW,EAAgBV,IAAIO,QASpBzC,GAAcY,UACb,IAAU,4BAA4BqD,KAAKrD,EAAQsD,YAOpDpE,GAAac,SACb2C,EAAU,OACZY,EAAsCvD,OAEnCuD,GAAWA,IAAYjE,SAASuB,SAEjC0C,EAAQC,WAAaC,KAAKC,cAC5Bf,EAAQxC,KAAKoD,GAGXA,EAAQI,mBAEHJ,EAAUA,EAAQI,cACvBhB,EAAQxC,KAAKoD,GAGfA,EAAUZ,EAAQQ,WAGpBI,EAAUA,EAAQ3C,YACb2C,EAA+BhB,YAE/BI,GAODxD,GAAyBa,SAEzB4D,EAAa5D,EAAQ4D,eACtBA,SACI,WAEHC,EAAS,IAAIjE,QACfQ,EACAY,EACA8C,QACEC,EAAQH,EAAWI,iBAAiB,WACtCD,EAAMhE,QAAUgE,EAAM,GAAGE,kBACtB7D,EAAI,EAAGA,EAAI2D,EAAMhE,OAAQK,QAC5B0D,EAAQC,EAAM3D,GAAG6D,cAAc,CAC7BC,SAAS,IAENlD,EAAI,EAAGA,EAAI8C,EAAM/D,OAAQiB,IACxB8C,EAAM9C,GAAGwC,WAAaC,KAAKC,cAC7BG,EAAOvC,IAAIwC,EAAM9C,WAMlB6C,KAnXb,GCrDA,MAAM5C,EAAQkD,MAAMC,UAAUnD,MAMxBoD,EACFC,QAAQF,UAAUC,SAAWC,QAAQF,UAAUG,kBAG7CC,EAA2B,CAAC,UACA,aACA,wBACA,yBACA,2BACA,yBACA,SACA,SACA,QACA,qBAAqBC,KAAK,KAkB5D,MAAMC,EAKJC,YAAYC,EAAaC,QAElBC,cAAgBD,OAGhBE,aAAeH,OAMfI,cAAgB,IAAIpF,IAGrBC,KAAKkF,aAAaE,aAAa,oBAE5BC,iBAAmBrF,KAAKkF,aAAaI,aAAa,oBAElDD,iBAAmB,UAErBH,aAAaK,aAAa,cAAe,aAGzCC,wBAAwBxF,KAAKkF,mBAO7BO,UAAY,IAAIpD,iBAAiBrC,KAAK0F,YAAYpD,KAAKtC,YACvDyF,UAAU9C,QAAQ3C,KAAKkF,aAAc,CAACS,YAAY,EAAM/C,WAAW,EAAMgD,SAAS,IAOzFC,kBACOJ,UAAU3D,aAEX9B,KAAKkF,eACuB,OAA1BlF,KAAKqF,sBACFH,aAAaK,aAAa,cAAevF,KAAKqF,uBAE9CH,aAAaY,gBAAgB,qBAIjCX,cAAcY,SAAQ,SAASC,QAC7BC,cAAcD,EAAUE,QAC5BlG,WAQEyF,oBACAP,uBACAC,wBACAF,6CAOE,IAAIlF,IAAIC,KAAKmF,+CAKa,OAA1BnF,KAAKqF,qCAIMc,QACbd,iBAAmBc,+BAKjBnG,KAAKqF,iBAMdG,wBAAwBY,GACtBC,EAAiBD,EAAYF,GAASlG,KAAKsG,WAAWJ,QAElDK,EAAgB9G,SAAS8G,kBAExB9G,SAASuB,KAAKwF,SAASJ,GAAY,KAElCF,EAAOE,EAEPK,OAAO7E,OACJsE,GAAM,IACPA,EAAKvC,WAAaC,KAAK8C,uBAAwB,CACjDD,EAAmCP,QAGrCA,EAAOA,EAAKnF,WAEV0F,IACFF,EAAgBE,EAAKF,eAGrBH,EAAUI,SAASD,KACrBA,EAAcI,OAIVJ,IAAkB9G,SAAS8G,eAC7B9G,SAASuB,KAAK4F,SAQpBN,WAAWJ,MACLA,EAAKvC,WAAaC,KAAKC,0BAGrB1D,EAAmC+F,EAIrC/F,IAAYH,KAAKkF,cAAgB/E,EAAQiF,aAAa,eACnDyB,gBAAgB1G,IAGnBqE,EAAQsC,KAAK3G,EAASwE,IAA6BxE,EAAQiF,aAAa,mBACrE2B,YAAY5G,GAQrB4G,YAAYb,SACJF,EAAYhG,KAAKiF,cAAc+B,SAASd,EAAMlG,WAC/CmF,cAAc1D,IAAIuE,GAOzBC,cAAcC,SACNF,EAAYhG,KAAKiF,cAAcgC,WAAWf,EAAMlG,MAClDgG,QACGb,cAAcxD,OAAOqE,GAQ9BkB,iBAAiBd,GACfC,EAAiBD,EAAYF,GAASlG,KAAKiG,cAAcC,IAO3DW,gBAAgBX,OACViB,EAAenH,KAAKiF,cAAcmC,aAAalB,GAI9CiB,SACElC,cAAcoC,SAASnB,GAAM,GAClCiB,EAAenH,KAAKiF,cAAcmC,aAAalB,IAGjDiB,EAAaG,aAAavB,SAAQ,SAASwB,QACpCR,YAAYQ,EAAerB,QAC/BlG,MAQL0F,YAAY8B,EAASC,GACnBD,EAAQzB,SAAQ,SAAS2B,SACjB1E,EAAkC0E,EAAO1E,UAC3B,cAAhB0E,EAAOC,KAETvG,EAAM0F,KAAKY,EAAOnE,YAAYwC,SAAQ,SAASG,QACxCV,wBAAwBU,KAC5BlG,MAGHoB,EAAM0F,KAAKY,EAAOvE,cAAc4C,SAAQ,SAASG,QAC1CgB,iBAAiBhB,KACrBlG,WACE,GAAoB,eAAhB0H,EAAOC,QACa,aAAzBD,EAAOE,mBAEJb,YAAY/D,QACZ,GAAIA,IAAWhD,KAAKkF,cACS,UAAzBwC,EAAOE,eACP5E,EAAOoC,aAAa,SAAU,MAGlCyB,gBAAgB7D,SACfmE,EAAenH,KAAKiF,cAAcmC,aAAapE,QAChDmC,cAAcY,SAAQ,SAAS8B,GAC9B7E,EAAOwD,SAASqB,EAAY3B,OAC9BiB,EAAaJ,YAAYc,EAAY3B,YAK5ClG,OAkBP,MAAM8H,EAKJhD,YAAYoB,EAAM6B,QAEXC,MAAQ9B,OAGR+B,sBAAuB,OAMvBC,YAAc,IAAInI,IAAI,CAACgI,SAGvBI,eAAiB,UAGjBC,YAAa,OAGbC,mBAOPxC,qBACOyC,oBAEDtI,KAAKgI,OAAShI,KAAKgI,MAAMrE,WAAaC,KAAKC,aAAc,OACrD1D,OAAwC6H,MAClB,OAAxBhI,KAAKmI,eACPhI,EAAQoF,aAAa,WAAYvF,KAAKmI,gBAEtChI,EAAQ2F,gBAAgB,YAItB9F,KAAKiI,6BACA9H,EAAQyG,WAKdoB,gBACAE,sBACAE,YAAa,yCAcpBE,uBACMtI,KAAKuI,gBACD,IAAItH,MAAM,sEAMa,OAAxBjB,KAAKmI,sCAKPG,oBACEtI,KAAKgI,wBAIIQ,QACXF,yBACAH,eAAiBK,kCAKjBF,oBACEtI,KAAKmI,eAIdE,sBACMrI,KAAKkG,KAAKvC,WAAaC,KAAKC,0BAG1B1D,OAAwC+F,QAC1C1B,EAAQsC,KAAK3G,EAASwE,GAA2B,KACK,IAAvBxE,EAASqI,UACtCxI,KAAKyI,wBAILtI,EAAQiF,aAAa,mBAClB+C,eAA8ChI,EAASqI,UAE9DrI,EAAQoF,aAAa,WAAY,MAC7BpF,EAAQwD,WAAaC,KAAKC,eAC5B1D,EAAQyG,MAAQ,kBACXqB,sBAAuB,QAErB9H,EAAQiF,aAAa,mBACzB+C,eAA8ChI,EAASqI,SAC5DrI,EAAQ2F,gBAAgB,aAQ5B4C,aAAaX,QACNO,yBACAJ,YAAYzG,IAAIsG,GASvBY,gBAAgBZ,QACTO,yBACAJ,YAAYvG,OAAOoG,GACM,IAA1B/H,KAAKkI,YAAYU,WACd/C,cA0MX,SAASQ,EAAiBH,EAAM2C,EAAUC,MACpC5C,EAAKvC,UAAYC,KAAKC,aAAc,OAChC1D,EAAmC+F,EACrC2C,GACFA,EAAS1I,SAOL4D,EAA0C5D,EAAS4D,cACrDA,cACFsC,EAAiBtC,EAAY8E,MAON,WAArB1I,EAAQsD,UAAwB,OAC5BsF,EAA8C5I,EAE9C6I,EAAmBD,EAAQE,oBAC/BF,EAAQE,sBAAwB,OAC7B,IAAI1I,EAAI,EAAGA,EAAIyI,EAAiB9I,OAAQK,IAC3C8F,EAAiB2C,EAAiBzI,GAAIsI,aAQjB,QAArB1I,EAAQsD,UAAqB,OACzByF,EAAwC/I,EAExC6I,EAAmBE,EAAK9E,cAC5B8E,EAAK9E,cAAc,CAACC,SAAS,IAAS,OACnC,IAAI9D,EAAI,EAAGA,EAAIyI,EAAiB9I,OAAQK,IAC3C8F,EAAiB2C,EAAiBzI,GAAIsI,eAQxCM,EAAQjD,EAAKkD,gBACD,MAATD,GACL9C,EAAiB8C,EAAON,GACxBM,EAAQA,EAAME,YAQlB,SAASC,EAAcpD,MACjBA,EAAKqD,cAAc,kCAGjBC,EAAQ/J,SAASgK,cAAc,SACrCD,EAAMjE,aAAa,KAAM,eACzBiE,EAAME,YAAc,oMAYpBxD,EAAKyD,YAAYH,GAInB,MAAMxE,EAAe,IA7QrB,MAIEF,YAAYrF,OACLA,QACG,IAAIwB,MAAM,0EAIb2I,UAAYnK,OAMZ0F,cAAgB,IAAI0E,SAMpB3B,YAAc,IAAI2B,SAMlBpE,UAAY,IAAIpD,iBAAiBrC,KAAK8J,eAAexH,KAAKtC,OAG/DsJ,EAAc7J,EAASsK,MAAQtK,EAASuB,MAAQvB,EAASuK,iBAG7B,YAAxBvK,EAASwK,WACXxK,EAASyK,iBAAiB,mBAAoBlK,KAAKmK,kBAAkB7H,KAAKtC,YAErEmK,oBAST9C,SAASZ,EAAMjF,MACTA,EAAO,IACLxB,KAAKkI,YAAYxG,IAAI+E,gBAInBsB,EAAY,IAAIlD,EAAU4B,EAAMzG,SACtCyG,EAAKlB,aAAa,QAAS,SACtB2C,YAAYkC,IAAI3D,EAAMsB,IAGtB/H,KAAK4J,UAAU5I,KAAKwF,SAASC,GAAO,KACnCxE,EAASwE,EAAK1F,gBACXkB,GACmB,KAApBA,EAAO0B,UACT2F,EAAcrH,GAEhBA,EAASA,EAAOlB,gBAGf,KACAf,KAAKkI,YAAYxG,IAAI+E,UAIRzG,KAAKkI,YAAYmC,IAAI5D,GAC7BZ,kBACLqC,YAAYvG,OAAO8E,GACxBA,EAAKX,gBAAgB,UASzBsB,aAAajH,UACJH,KAAKkI,YAAYmC,IAAIlK,GAW9B6G,SAASd,EAAM6B,OACT/B,EAAYhG,KAAKmF,cAAckF,IAAInE,eACrBtE,IAAdoE,EACFA,EAAU0C,aAAaX,GAEvB/B,EAAY,IAAI8B,EAAU5B,EAAM6B,QAG7B5C,cAAciF,IAAIlE,EAAMF,GAEtBA,EAYTiB,WAAWf,EAAM6B,SACT/B,EAAYhG,KAAKmF,cAAckF,IAAInE,UACpCF,GAILA,EAAU2C,gBAAgBZ,GACtB/B,EAAUuC,gBACPpD,cAAcxD,OAAOuE,GAGrBF,GARE,KAcXmE,oBAEwB/I,EAAM0F,KAAK9G,KAAK4J,UAAUzF,iBAAiB,YACnD4B,SAAQ,SAASuE,QACxBjD,SAASiD,GAAc,KAC3BtK,WAGEyF,UAAU9C,QAAQ3C,KAAK4J,UAAU5I,KAAM,CAAC2E,YAAY,EAAMC,SAAS,EAAMhD,WAAW,IAQ3FkH,eAAetC,EAASC,SAChB8C,EAAQvK,KACdwH,EAAQzB,SAAQ,SAAS2B,UACfA,EAAOC,UACV,YACHvG,EAAM0F,KAAKY,EAAOnE,YAAYwC,SAAQ,SAASG,MACzCA,EAAKvC,WAAaC,KAAKC,0BAGrB2G,EAAgBpJ,EAAM0F,KAAKZ,EAAK/B,iBAAiB,YACnDK,EAAQsC,KAAKZ,EAAM,YACrBsE,EAAcC,QAAQvE,GAExBsE,EAAczE,SAAQ,SAASuE,QACxBjD,SAASiD,GAAc,KAC3BC,KACFA,aAEA,gBAC0B,UAAzB7C,EAAOE,2BAGL5E,EAAkC0E,EAAO1E,OACzCxB,EAAQwB,EAAOoC,aAAa,SAClCmF,EAAMlD,SAASrE,EAAQxB,MAGxBxB,QA4F+BP,UAEjCgF,QAAQF,UAAUmG,eAAe,UACpCC,OAAOC,eAAenG,QAAQF,UAAW,QAAS,CAChDsG,YAAY,EAEZR,IAAK,kBACIrK,KAAKoF,aAAa,UAG3BgF,IAAK,SAAS5I,GACZwD,EAAaqC,SAASrH,KAAMwB"}